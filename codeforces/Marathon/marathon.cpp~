#include <bits/stdc++.h>
#define TAM 5000
#define ND 1000
#define ATTEMPT 100
#define WRONG 2000
using namespace std;

typedef pair<int,int> ii;
typedef struct{
  int best;
  ii range;
}Seg;
int tested=0;
int k;
bitset<TAM+1> disc;
bitset<TAM+1> curr;

bool myfunction (ii i,ii j) { return (i.second<j.second); }

void send (){
  if (tested >= ATTEMPT) return;
  tested++;
  for (int i = 0; i < TAM; i++) cout << curr[i]; cout << endl; fflush(stdout);
  cin >> k;
  disc[k-1] = 1;
  curr[k-1] = (~curr[k-1]);
}

void build (Seg v[], int i, int b, int e){
  if (b==e){
    v[i].range.first = v[i].range.second = b;
    return;
  }
  v[i].range.first = b;
  v[i].range.second = e;
  
  int mid = (b+e)/2;
  build(v,2*i+1,b,mid);
  build(v,2*i+2,mid,e);
}

int find (Seg v[], int i){
  if (v[i].range.first==v[i].range.second) return i;
  if (!visited[2*i+1]) return 2*i+1;
  if (!visited[2*i+2]) return 2*i+2;
  if (v[2*i+1].best > v[2*i+2].best) return find(v,2*i+2);
  else return find(v,2*i+1);
}

void update(Seg &v[], bitset<3*TAM> &visited, int i){
  visited[i] = 1;
  int ant = k;
  for (int g = v[i].range.first; g < v[i].range.second; g++) curr[g] = (~curr[g]);
  send();
  if (ant > k) for (int g = v[i].range.first; g < v[i].range.second; g++) curr[g] = (~curr[g]);
  else{
    v[i].best = k;
    for (int j = 0; j != i; ){
      v[j].best += ant
      int mid1 = (v[j].range.first + v[j].range.second)/2;
      int mid2 = (v[i].range.first + v[i].range.second)/2;
      if (mid2 > mid1) j = 2*i+1;
      else j = 2*i+2;
    }
}

void test (){
  Seg v[3*TAM];
  bitset<3*TAM> visited;

  for (int i = 0; i < 3*TAM; i++) visited[i] = 0;

  v[0].best = k;
  visited[0] = 1;
  v[0].range.first = 0;
  v[0].range.second = TAM;

  build(v, 0, 0, TAM);

  while (tested < ATTEMPT)
    update(v, visited, find(v,0));
}

int main ()
{
  srand(12345);

  for (int i = 0; i < TAM; i++){
    curr[i] = rand()%2;
    disc[i] = 0;
  }
  send ();
  
  test();

  return 0;
}
